<%- include('partials/header') %>

<style>
  /* Override container for full-width cockpit layout */
  main.container {
    max-width: none;
    padding: 0;
    margin: 0;
    width: 100%;
  }
</style>

<div class="cockpit-layout">
  <!-- Chat Panel (Left) -->
  <div class="cockpit-chat">
    <div class="chat-header">
      <div>
        <h1 id="chatTitle"><%= conversation.title || 'Module Writer Cockpit' %></h1>
        <div class="chat-meta">
          <span class="experiment-id"><%= conversation.agentId %>/<%= conversation.agentVersion %></span>
          <span class="text-muted">&#8226;</span>
          <a href="/conversations?id=<%= conversation.id %>" class="text-muted">Exit Cockpit</a>
        </div>
      </div>
    </div>

    <div class="chat-messages" id="messages">
      <%
        // Group consecutive assistant messages
        const groupedMessages = [];
        for (const msg of messages) {
          const last = groupedMessages[groupedMessages.length - 1];
          const msgParts = [];
          if (msg.toolExecutions?.length > 0) {
            msgParts.push({ type: 'tools', tools: msg.toolExecutions });
          }
          if (msg.content) {
            msgParts.push({ type: 'content', text: msg.content });
          }
          if (msg.role === 'assistant' && last?.role === 'assistant') {
            last.parts.push(...msgParts);
          } else {
            groupedMessages.push({ role: msg.role, parts: msgParts });
          }
        }
      %>
      <% if (groupedMessages.length === 0) { %>
        <div class="empty-state">
          <p>No messages yet. The agent is ready to help you build a module.</p>
        </div>
      <% } else { %>
        <% groupedMessages.forEach(msg => { %>
          <div class="message message-<%= msg.role %>">
            <div class="message-header">
              <span class="message-role"><%= msg.role %></span>
            </div>
            <% msg.parts.forEach(part => { %>
              <% if (part.type === 'tools') { %>
                <div class="tool-executions">
                  <% part.tools.forEach(tool => {
                    const summary = tool.input.name || tool.input.id || tool.input.moduleId || '';
                  %>
                    <div class="tool-execution" data-tool-id="<%= tool.id %>">
                      <div class="tool-pill" onclick="toggleToolExecution(this)">
                        <span class="tool-pill-icon">&#9654;</span>
                        <span class="tool-pill-name"><%= tool.name %><% if (summary) { %>("<%= summary %>")<% } %></span>
                        <span class="tool-pill-duration"><%= tool.durationMs %>ms</span>
                        <span class="tool-pill-status <%= tool.result.success ? 'success' : 'error' %>"><%= tool.result.success ? '&#10003;' : '&#10007;' %></span>
                      </div>
                      <div class="tool-details">
                        <pre class="tool-json"><%= JSON.stringify(tool.input) %> &rarr; <%= tool.result.error ? tool.result.error : JSON.stringify(tool.result.output) %></pre>
                      </div>
                    </div>
                  <% }) %>
                </div>
              <% } else { %>
                <div class="message-content" data-raw="<%= encodeURIComponent(part.text) %>"></div>
              <% } %>
            <% }) %>
          </div>
        <% }) %>
      <% } %>
    </div>

    <form class="chat-input" id="chatForm">
      <input type="hidden" name="conversationId" value="<%= conversation.id %>">
      <textarea
        name="content"
        id="messageInput"
        placeholder="Describe the module you want to build..."
        rows="2"
        required
      ></textarea>
      <button type="submit" class="btn btn-primary">Send</button>
    </form>
  </div>

  <!-- Side Panel (Right) -->
  <div class="cockpit-side-panel">
    <!-- Mock Server Control -->
    <div class="mock-server-card">
      <h3>Mock Server</h3>
      <div class="server-status" id="serverStatus">
        <span class="status-indicator <%= session.mockServerStatus %>" id="statusIndicator"></span>
        <span id="statusText"><%= session.mockServerStatus %></span>
      </div>
      <div class="server-info" id="serverInfo" style="<%= session.mockServerGameServerId ? '' : 'display:none' %>">
        <small class="text-muted">ID: <span id="gameServerId"><%= session.mockServerGameServerId || '' %></span></small>
      </div>
      <div class="server-controls">
        <% if (session.mockServerStatus === 'running') { %>
          <button class="btn btn-danger-outline btn-small" onclick="stopMockServer()">Stop</button>
          <button class="btn btn-small" onclick="sendMockCommand('connectAll')">Connect All</button>
          <button class="btn btn-small" onclick="sendMockCommand('disconnectAll')">Disconnect All</button>
        <% } else if (session.mockServerStatus === 'starting') { %>
          <button class="btn btn-small" disabled>Starting...</button>
        <% } else { %>
          <button class="btn btn-primary btn-small" onclick="startMockServer()">Start Server</button>
        <% } %>
      </div>
    </div>

    <!-- Player Picker -->
    <div class="player-picker" id="playerPicker" style="<%= session.mockServerStatus === 'running' ? '' : 'display:none' %>">
      <h3>Players</h3>
      <p class="text-muted small">Select a player for command testing</p>
      <div class="player-list" id="playerList">
        <div class="loading-state">Loading players...</div>
      </div>
    </div>

    <!-- Live Event Stream -->
    <div class="event-stream-container">
      <div class="event-stream-header">
        <h3>Live Events</h3>
        <select id="eventFilter" class="form-control form-control-small">
          <option value="all">All Events</option>
          <option value="command-executed">Commands</option>
          <option value="hook-executed">Hooks</option>
          <option value="cronjob-executed">Cron Jobs</option>
          <option value="chat-message">Chat</option>
        </select>
      </div>
      <div class="event-stream" id="eventStream">
        <% if (session.mockServerStatus !== 'running') { %>
          <div class="empty-state">
            <p>Start the mock server to see live events</p>
          </div>
        <% } else { %>
          <div class="empty-state" id="eventEmptyState">
            <p>Waiting for events...</p>
          </div>
        <% } %>
      </div>
    </div>
  </div>
</div>

<script>
  // Session state
  const sessionId = '<%= session.id %>';
  const conversationId = '<%= conversation.id %>';
  let mockServerStatus = '<%= session.mockServerStatus %>';
  let selectedPlayerId = '<%= session.selectedPlayerId || "" %>';
  let eventSource = null;
  let eventFilter = 'all';
  const pendingTools = new Map();

  // Configure marked.js
  marked.setOptions({
    breaks: true,
    gfm: true,
    highlight: function(code, lang) {
      if (lang && hljs.getLanguage(lang)) {
        return hljs.highlight(code, { language: lang }).value;
      }
      return hljs.highlightAuto(code).value;
    }
  });

  function renderMarkdown(text) {
    if (!text) return '';
    return marked.parse(text);
  }

  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  function toggleToolExecution(pill) {
    pill.parentElement.classList.toggle('expanded');
    const icon = pill.querySelector('.tool-pill-icon');
    if (icon) icon.innerHTML = pill.parentElement.classList.contains('expanded') ? '&#9660;' : '&#9654;';
  }

  function getToolSummary(input) {
    return input.name || input.id || input.moduleId || '';
  }

  function formatTime(dateStr) {
    return new Date(dateStr).toLocaleTimeString();
  }

  // Mock Server Controls
  async function startMockServer() {
    updateServerStatus('starting');
    try {
      const res = await fetch('/api/cockpit/sessions/' + sessionId + '/mock-server/start', { method: 'POST' });
      const data = await res.json();
      if (res.ok && data.data) {
        updateServerStatus(data.data.status, data.data.gameServerId);
        loadPlayers();
        connectEventStream();
      } else {
        updateServerStatus('error');
        alert(data.error || 'Failed to start mock server');
      }
    } catch (err) {
      updateServerStatus('error');
      alert('Failed to start mock server: ' + err.message);
    }
  }

  async function stopMockServer() {
    updateServerStatus('stopping');
    try {
      await fetch('/api/cockpit/sessions/' + sessionId + '/mock-server/stop', { method: 'POST' });
      updateServerStatus('stopped');
      disconnectEventStream();
    } catch (err) {
      alert('Failed to stop mock server: ' + err.message);
    }
  }

  async function sendMockCommand(command) {
    try {
      await fetch('/api/cockpit/sessions/' + sessionId + '/mock-server/command', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ command })
      });
      // Refresh players after connect/disconnect
      if (command === 'connectAll' || command === 'disconnectAll') {
        setTimeout(loadPlayers, 1000);
      }
    } catch (err) {
      alert('Failed to send command: ' + err.message);
    }
  }

  function updateServerStatus(status, gameServerId) {
    mockServerStatus = status;
    const indicator = document.getElementById('statusIndicator');
    const statusText = document.getElementById('statusText');
    const serverInfo = document.getElementById('serverInfo');
    const serverIdEl = document.getElementById('gameServerId');
    const playerPicker = document.getElementById('playerPicker');

    indicator.className = 'status-indicator ' + status;
    statusText.textContent = status;

    if (gameServerId) {
      serverInfo.style.display = '';
      serverIdEl.textContent = gameServerId;
    }

    // Update controls
    const controls = document.querySelector('.server-controls');
    if (status === 'running') {
      controls.innerHTML = `
        <button class="btn btn-danger-outline btn-small" onclick="stopMockServer()">Stop</button>
        <button class="btn btn-small" onclick="sendMockCommand('connectAll')">Connect All</button>
        <button class="btn btn-small" onclick="sendMockCommand('disconnectAll')">Disconnect All</button>
      `;
      playerPicker.style.display = '';
    } else if (status === 'starting' || status === 'stopping') {
      controls.innerHTML = `<button class="btn btn-small" disabled>${status === 'starting' ? 'Starting...' : 'Stopping...'}</button>`;
    } else {
      controls.innerHTML = `<button class="btn btn-primary btn-small" onclick="startMockServer()">Start Server</button>`;
      playerPicker.style.display = 'none';
      serverInfo.style.display = 'none';
    }

    // Update event stream empty state
    const emptyState = document.getElementById('eventEmptyState');
    if (emptyState) {
      emptyState.innerHTML = status === 'running'
        ? '<p>Waiting for events...</p>'
        : '<p>Start the mock server to see live events</p>';
    }
  }

  // Player Management
  async function loadPlayers() {
    const playerList = document.getElementById('playerList');
    playerList.innerHTML = '<div class="loading-state">Loading players...</div>';

    try {
      const res = await fetch('/api/cockpit/sessions/' + sessionId + '/players');
      const data = await res.json();

      if (data.data?.players?.length > 0) {
        selectedPlayerId = data.data.selectedPlayerId || data.data.players[0].id;
        playerList.innerHTML = data.data.players.map(p => `
          <label class="player-item ${p.id === selectedPlayerId ? 'selected' : ''}">
            <input type="radio" name="player" value="${p.id}" ${p.id === selectedPlayerId ? 'checked' : ''} onchange="selectPlayer('${p.id}')">
            <span class="player-name">${escapeHtml(p.name)}</span>
            <span class="player-id text-muted">${escapeHtml(p.gameId)}</span>
          </label>
        `).join('');
      } else {
        playerList.innerHTML = '<div class="empty-state small"><p>No players connected</p></div>';
      }
    } catch (err) {
      playerList.innerHTML = '<div class="empty-state small"><p>Failed to load players</p></div>';
    }
  }

  async function selectPlayer(playerId) {
    selectedPlayerId = playerId;
    try {
      await fetch('/api/cockpit/sessions/' + sessionId + '/select-player', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ playerId })
      });
      // Update UI
      document.querySelectorAll('.player-item').forEach(item => {
        item.classList.toggle('selected', item.querySelector('input').value === playerId);
      });
    } catch (err) {
      console.error('Failed to select player:', err);
    }
  }

  // Event Stream
  function connectEventStream() {
    if (eventSource) {
      eventSource.close();
    }

    eventSource = new EventSource('/api/cockpit/sessions/' + sessionId + '/events');

    eventSource.addEventListener('connected', (e) => {
      console.log('Event stream connected:', JSON.parse(e.data));
    });

    eventSource.addEventListener('event', (e) => {
      const event = JSON.parse(e.data);
      addEventToStream(event);
    });

    eventSource.addEventListener('heartbeat', (e) => {
      // Keep-alive, no action needed
    });

    eventSource.onerror = (e) => {
      console.error('Event stream error:', e);
      // Auto-reconnect after 5 seconds
      setTimeout(() => {
        if (mockServerStatus === 'running') {
          connectEventStream();
        }
      }, 5000);
    };
  }

  function disconnectEventStream() {
    if (eventSource) {
      eventSource.close();
      eventSource = null;
    }
  }

  function addEventToStream(event) {
    // Check filter
    if (eventFilter !== 'all' && event.eventName !== eventFilter) {
      return;
    }

    const container = document.getElementById('eventStream');

    // Remove empty state if present
    const emptyState = container.querySelector('.empty-state');
    if (emptyState) emptyState.remove();

    const success = event.meta?.result?.success !== false;
    const el = document.createElement('div');
    el.className = 'event-item ' + (success ? 'event-success' : 'event-error');
    el.innerHTML = `
      <div class="event-header" onclick="toggleEventLogs(this)">
        <span class="event-icon">&#9654;</span>
        <span class="event-name">${escapeHtml(event.eventName)}</span>
        <span class="event-time">${formatTime(event.createdAt)}</span>
        <span class="event-status">${success ? '&#10003;' : '&#10007;'}</span>
      </div>
      <div class="event-summary">${getEventSummary(event)}</div>
      <div class="event-logs">${formatLogs(event.meta)}</div>
    `;
    container.insertBefore(el, container.firstChild);

    // Limit to 100 events
    while (container.children.length > 100) {
      container.removeChild(container.lastChild);
    }
  }

  function toggleEventLogs(header) {
    const item = header.parentElement;
    item.classList.toggle('expanded');
    const icon = header.querySelector('.event-icon');
    if (icon) icon.innerHTML = item.classList.contains('expanded') ? '&#9660;' : '&#9654;';
  }

  function getEventSummary(event) {
    const meta = event.meta || {};
    if (event.eventName === 'command-executed' && meta.command) {
      return escapeHtml(meta.command.name || 'command');
    }
    if (event.eventName === 'hook-executed' && meta.hook) {
      return escapeHtml(meta.hook.name || 'hook');
    }
    if (event.eventName === 'cronjob-executed' && meta.cronjob) {
      return escapeHtml(meta.cronjob.name || 'cronjob');
    }
    if (event.eventName === 'chat-message' && meta.msg) {
      return escapeHtml(meta.msg.substring(0, 50));
    }
    return '';
  }

  function formatLogs(meta) {
    if (!meta) return '';
    const logs = meta.result?.logs || [];
    if (logs.length === 0) {
      return '<span class="text-muted">No logs</span>';
    }
    return logs.map(log => {
      const details = log.details ? '\n  ' + (typeof log.details === 'string' ? log.details : JSON.stringify(log.details, null, 2)) : '';
      return escapeHtml(log.msg + details);
    }).join('\n');
  }

  // Event filter
  document.getElementById('eventFilter').addEventListener('change', (e) => {
    eventFilter = e.target.value;
  });

  // Chat handling (same as chat.ejs)
  async function handleSubmit(e) {
    e.preventDefault();
    const input = document.getElementById('messageInput');
    const messagesContainer = document.getElementById('messages');
    const content = input.value.trim();
    if (!content) return;

    // Add user message to UI
    addMessage('user', content);
    input.value = '';

    // Create assistant message placeholder
    const assistantMsg = addMessage('assistant', '');
    pendingTools.clear();

    // Send to API with SSE
    const response = await fetch('/api/conversations/' + conversationId + '/messages', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ content })
    });

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split('\n');
      buffer = lines.pop() || '';

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          try {
            const data = JSON.parse(line.slice(6));
            if (data.type === 'text') {
              if (!assistantMsg._rawContent) assistantMsg._rawContent = '';
              assistantMsg._rawContent += data.content;
              assistantMsg.querySelector('.message-content').innerHTML = renderMarkdown(assistantMsg._rawContent);
            } else if (data.type === 'tool_use') {
              addPendingToolExecution(assistantMsg, data.id, data.name, data.input);
            } else if (data.type === 'tool_result') {
              updateToolExecutionResult(assistantMsg, data.id, data.name, data.result, data.durationMs);
            } else if (data.type === 'error' || data.error) {
              assistantMsg.classList.add('message-error');
              assistantMsg.querySelector('.message-content').textContent =
                'Error: ' + (data.error || data.message || 'Unknown error');
            }
          } catch (e) {}
        }
      }
    }

    messagesContainer.scrollTop = messagesContainer.scrollHeight;
  }

  function addMessage(role, content) {
    const messagesContainer = document.getElementById('messages');
    const emptyState = messagesContainer.querySelector('.empty-state');
    if (emptyState) emptyState.remove();

    const div = document.createElement('div');
    div.className = 'message message-' + role;
    const renderedContent = role === 'assistant' ? renderMarkdown(content) : escapeHtml(content);
    div.innerHTML =
      '<div class="message-header"><span class="message-role">' + role + '</span></div>' +
      '<div class="message-content">' + renderedContent + '</div>';
    messagesContainer.appendChild(div);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
    return div;
  }

  function addPendingToolExecution(msgEl, toolId, toolName, input) {
    let container = msgEl.querySelector('.tool-executions');
    if (!container) {
      container = document.createElement('div');
      container.className = 'tool-executions';
      msgEl.appendChild(container);
    }

    const summary = getToolSummary(input);
    const toolEl = document.createElement('div');
    toolEl.className = 'tool-execution';
    toolEl.dataset.toolId = toolId;
    toolEl.innerHTML = `
      <div class="tool-pill" onclick="toggleToolExecution(this)">
        <span class="tool-pill-icon">&#9654;</span>
        <span class="tool-pill-name">${escapeHtml(toolName)}${summary ? '("' + escapeHtml(summary) + '")' : ''}</span>
        <span class="tool-pill-duration">...</span>
        <span class="tool-pill-status pending">&#8987;</span>
      </div>
      <div class="tool-details">
        <pre class="tool-json">${escapeHtml(JSON.stringify(input))} &rarr; waiting...</pre>
      </div>
    `;
    container.appendChild(toolEl);
    pendingTools.set(toolId, { name: toolName, input });

    document.getElementById('messages').scrollTop = document.getElementById('messages').scrollHeight;
  }

  function updateToolExecutionResult(msgEl, toolId, toolName, result, durationMs) {
    const toolEl = msgEl.querySelector('.tool-execution[data-tool-id="' + toolId + '"]');
    if (!toolEl) {
      addPendingToolExecution(msgEl, toolId, toolName, {});
      setTimeout(() => updateToolExecutionResult(msgEl, toolId, toolName, result, durationMs), 10);
      return;
    }

    const durationEl = toolEl.querySelector('.tool-pill-duration');
    if (durationEl) durationEl.textContent = durationMs + 'ms';

    const statusEl = toolEl.querySelector('.tool-pill-status');
    if (statusEl) {
      statusEl.className = 'tool-pill-status ' + (result.success ? 'success' : 'error');
      statusEl.innerHTML = result.success ? '&#10003;' : '&#10007;';
    }

    const pending = pendingTools.get(toolId);
    const inputJson = pending ? JSON.stringify(pending.input) : '{}';
    const outputJson = result.error ? result.error : JSON.stringify(result.output);
    const jsonEl = toolEl.querySelector('.tool-json');
    if (jsonEl) jsonEl.textContent = inputJson + ' \u2192 ' + outputJson;

    pendingTools.delete(toolId);
  }

  // Initialize
  document.getElementById('chatForm').addEventListener('submit', handleSubmit);
  document.getElementById('messageInput').addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      document.getElementById('chatForm').requestSubmit();
    }
  });

  // Render markdown for server-rendered messages
  document.querySelectorAll('.message-content[data-raw]').forEach(el => {
    const rawText = decodeURIComponent(el.dataset.raw);
    el.innerHTML = renderMarkdown(rawText);
    delete el.dataset.raw;
  });

  // Scroll to bottom on load
  const messagesContainer = document.getElementById('messages');
  if (messagesContainer) {
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
  }

  // Auto-start mock server on load if not running
  <% if (session.mockServerStatus !== 'running' && session.mockServerStatus !== 'starting') { %>
    startMockServer();
  <% } else if (session.mockServerStatus === 'running') { %>
    // Already running, connect event stream and load players
    connectEventStream();
    loadPlayers();
  <% } %>
</script>

<%- include('partials/footer') %>
