<%- include('partials/header') %>

<div class="chat-page">
  <div class="chat-header">
    <div>
      <h1><%= conversation.title || 'Chat' %></h1>
      <div class="chat-meta">
        <span class="badge"><%= conversation.agentId %></span>
        <span class="badge badge-outline">v<%= conversation.agentVersion %></span>
        <span class="text-muted"><%= new Date(conversation.createdAt).toLocaleString() %></span>
      </div>
    </div>
    <a href="/conversations" class="btn btn-secondary">Back</a>
  </div>

  <div class="chat-messages" id="messages">
    <% if (messages.length === 0) { %>
      <div class="empty-state">
        <p>No messages yet. Start the conversation below.</p>
      </div>
    <% } else { %>
      <% messages.forEach(msg => { %>
        <div class="message message-<%= msg.role %>">
          <div class="message-header">
            <span class="message-role"><%= msg.role %></span>
          </div>
          <div class="message-content"><%= msg.content %></div>
          <% if (msg.toolExecutions && msg.toolExecutions.length > 0) { %>
            <div class="tool-executions">
              <% msg.toolExecutions.forEach((tool, idx) => { %>
                <div class="tool-execution" data-tool-id="<%= tool.id %>">
                  <div class="tool-execution-header" onclick="toggleToolExecution(this)">
                    <span class="tool-name">
                      <span class="icon">▶</span>
                      <%= tool.name %>
                    </span>
                    <span class="tool-meta">
                      <span class="tool-duration"><%= tool.durationMs %>ms</span>
                      <span class="tool-status <%= tool.result.success ? 'success' : 'error' %>">
                        <%= tool.result.success ? 'success' : 'error' %>
                      </span>
                    </span>
                  </div>
                  <div class="tool-execution-body">
                    <div class="tool-section">
                      <div class="tool-section-label">Input</div>
                      <div class="tool-section-content">
                        <pre><%= JSON.stringify(tool.input, null, 2) %></pre>
                      </div>
                    </div>
                    <div class="tool-section">
                      <div class="tool-section-label">Output</div>
                      <div class="tool-section-content">
                        <pre><%= tool.result.error ? tool.result.error : JSON.stringify(tool.result.output, null, 2) %></pre>
                      </div>
                    </div>
                  </div>
                </div>
              <% }) %>
            </div>
          <% } %>
        </div>
      <% }) %>
    <% } %>
  </div>

  <form class="chat-input" id="chatForm">
    <input type="hidden" name="conversationId" value="<%= conversation.id %>">
    <textarea
      name="content"
      id="messageInput"
      placeholder="Type your message..."
      rows="2"
      required
    ></textarea>
    <button type="submit" class="btn btn-primary">Send</button>
  </form>
</div>

<script>
  const form = document.getElementById('chatForm');
  const messagesContainer = document.getElementById('messages');
  const input = document.getElementById('messageInput');
  const conversationId = '<%= conversation.id %>';

  // Track pending tool calls during streaming
  const pendingTools = new Map();

  function toggleToolExecution(header) {
    header.parentElement.classList.toggle('expanded');
  }

  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    const content = input.value.trim();
    if (!content) return;

    // Add user message to UI
    addMessage('user', content);
    input.value = '';

    // Create assistant message placeholder
    const assistantMsg = addMessage('assistant', '');
    pendingTools.clear();

    // Send to API with SSE
    const response = await fetch('/api/conversations/' + conversationId + '/messages', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ content })
    });

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split('\n');
      buffer = lines.pop() || '';

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          try {
            const data = JSON.parse(line.slice(6));
            if (data.type === 'text') {
              assistantMsg.querySelector('.message-content').textContent += data.content;
            } else if (data.type === 'tool_use') {
              // Add pending tool execution UI
              addPendingToolExecution(assistantMsg, data.id, data.name, data.input);
            } else if (data.type === 'tool_result') {
              // Update tool execution with result
              updateToolExecutionResult(assistantMsg, data.id, data.name, data.result, data.durationMs);
            } else if (data.type === 'error' || data.error) {
              assistantMsg.classList.add('message-error');
              assistantMsg.querySelector('.message-content').textContent =
                'Error: ' + (data.error || data.message || 'Unknown error');
            }
          } catch (e) {}
        } else if (line.startsWith('event: error')) {
          // Next data line will be the error
        }
      }
    }

    messagesContainer.scrollTop = messagesContainer.scrollHeight;
  });

  function addMessage(role, content) {
    // Remove empty state if present
    const emptyState = messagesContainer.querySelector('.empty-state');
    if (emptyState) emptyState.remove();

    const div = document.createElement('div');
    div.className = 'message message-' + role;
    div.innerHTML =
      '<div class="message-header"><span class="message-role">' + role + '</span></div>' +
      '<div class="message-content">' + escapeHtml(content) + '</div>';
    messagesContainer.appendChild(div);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
    return div;
  }

  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  function addPendingToolExecution(msgEl, toolId, toolName, input) {
    let container = msgEl.querySelector('.tool-executions');
    if (!container) {
      container = document.createElement('div');
      container.className = 'tool-executions';
      msgEl.appendChild(container);
    }

    const toolEl = document.createElement('div');
    toolEl.className = 'tool-execution';
    toolEl.dataset.toolId = toolId;
    toolEl.innerHTML = `
      <div class="tool-execution-header" onclick="toggleToolExecution(this)">
        <span class="tool-name">
          <span class="icon">▶</span>
          ${escapeHtml(toolName)}
        </span>
        <span class="tool-meta">
          <span class="tool-duration">running...</span>
          <span class="tool-status" style="background: rgba(210, 153, 34, 0.2); color: var(--accent-warning);">pending</span>
        </span>
      </div>
      <div class="tool-execution-body">
        <div class="tool-section">
          <div class="tool-section-label">Input</div>
          <div class="tool-section-content">
            <pre>${escapeHtml(JSON.stringify(input, null, 2))}</pre>
          </div>
        </div>
        <div class="tool-section tool-output-section">
          <div class="tool-section-label">Output</div>
          <div class="tool-section-content">
            <pre>Waiting for result...</pre>
          </div>
        </div>
      </div>
    `;
    container.appendChild(toolEl);
    pendingTools.set(toolId, { name: toolName, input });
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
  }

  function updateToolExecutionResult(msgEl, toolId, toolName, result, durationMs) {
    const toolEl = msgEl.querySelector(`.tool-execution[data-tool-id="${toolId}"]`);
    if (!toolEl) {
      // Tool wasn't tracked, create it with result
      addPendingToolExecution(msgEl, toolId, toolName, {});
      setTimeout(() => updateToolExecutionResult(msgEl, toolId, toolName, result, durationMs), 10);
      return;
    }

    // Update duration
    const durationEl = toolEl.querySelector('.tool-duration');
    if (durationEl) {
      durationEl.textContent = durationMs + 'ms';
    }

    // Update status
    const statusEl = toolEl.querySelector('.tool-status');
    if (statusEl) {
      if (result.success) {
        statusEl.className = 'tool-status success';
        statusEl.textContent = 'success';
      } else {
        statusEl.className = 'tool-status error';
        statusEl.textContent = 'error';
      }
    }

    // Update output
    const outputSection = toolEl.querySelector('.tool-output-section .tool-section-content pre');
    if (outputSection) {
      outputSection.textContent = result.error
        ? result.error
        : JSON.stringify(result.output, null, 2);
    }

    pendingTools.delete(toolId);
  }

  // Scroll to bottom on load
  messagesContainer.scrollTop = messagesContainer.scrollHeight;
</script>

<%- include('partials/footer') %>
