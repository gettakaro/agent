<%- include('partials/header') %>

<div class="chat-page">
  <div class="chat-header">
    <div>
      <h1><%= conversation.title || 'Chat' %></h1>
      <div class="chat-meta">
        <span class="experiment-id"><%= conversation.agentId %>/<%= conversation.agentVersion %></span>
        <span class="text-muted">•</span>
        <span class="text-muted"><%= new Date(conversation.createdAt).toLocaleString() %></span>
      </div>
    </div>
    <a href="/conversations" class="btn btn-secondary">Back</a>
  </div>

  <div class="chat-messages" id="messages">
    <%
      // Group consecutive assistant messages, preserving chronological order via parts array
      const groupedMessages = [];
      for (const msg of messages) {
        const last = groupedMessages[groupedMessages.length - 1];

        // Build parts for this message (tools first, then content)
        const msgParts = [];
        if (msg.toolExecutions?.length > 0) {
          msgParts.push({ type: 'tools', tools: msg.toolExecutions });
        }
        if (msg.content) {
          msgParts.push({ type: 'content', text: msg.content });
        }

        if (msg.role === 'assistant' && last?.role === 'assistant') {
          // Append parts to existing group
          last.parts.push(...msgParts);
        } else {
          groupedMessages.push({ role: msg.role, parts: msgParts });
        }
      }
    %>
    <% if (groupedMessages.length === 0) { %>
      <div class="empty-state">
        <p>No messages yet. Start the conversation below.</p>
      </div>
    <% } else { %>
      <% groupedMessages.forEach(msg => { %>
        <div class="message message-<%= msg.role %>">
          <div class="message-header">
            <span class="message-role"><%= msg.role %></span>
          </div>
          <% msg.parts.forEach(part => { %>
            <% if (part.type === 'tools') { %>
              <div class="tool-executions">
                <% part.tools.forEach(tool => {
                  const summary = tool.input.name || tool.input.id || tool.input.moduleId || '';
                %>
                  <div class="tool-execution" data-tool-id="<%= tool.id %>">
                    <div class="tool-pill" onclick="toggleToolExecution(this)">
                      <span class="tool-pill-icon">▶</span>
                      <span class="tool-pill-name"><%= tool.name %><% if (summary) { %>("<%= summary %>")<% } %></span>
                      <span class="tool-pill-duration"><%= tool.durationMs %>ms</span>
                      <span class="tool-pill-status <%= tool.result.success ? 'success' : 'error' %>"><%= tool.result.success ? '✓' : '✗' %></span>
                    </div>
                    <div class="tool-details">
                      <pre class="tool-json"><%= JSON.stringify(tool.input) %> → <%= tool.result.error ? tool.result.error : JSON.stringify(tool.result.output) %></pre>
                    </div>
                  </div>
                <% }) %>
              </div>
            <% } else { %>
              <div class="message-content"><%= part.text %></div>
            <% } %>
          <% }) %>
        </div>
      <% }) %>
    <% } %>
  </div>

  <form class="chat-input" id="chatForm">
    <input type="hidden" name="conversationId" value="<%= conversation.id %>">
    <textarea
      name="content"
      id="messageInput"
      placeholder="Type your message..."
      rows="2"
      required
    ></textarea>
    <button type="submit" class="btn btn-primary">Send</button>
  </form>
</div>

<script>
  const form = document.getElementById('chatForm');
  const messagesContainer = document.getElementById('messages');
  const input = document.getElementById('messageInput');
  const conversationId = '<%= conversation.id %>';

  // Track pending tool calls during streaming
  const pendingTools = new Map();

  function toggleToolExecution(pill) {
    pill.parentElement.classList.toggle('expanded');
    const icon = pill.querySelector('.tool-pill-icon');
    if (icon) icon.textContent = pill.parentElement.classList.contains('expanded') ? '▼' : '▶';
  }

  function getToolSummary(input) {
    return input.name || input.id || input.moduleId || '';
  }

  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    const content = input.value.trim();
    if (!content) return;

    // Add user message to UI
    addMessage('user', content);
    input.value = '';

    // Create assistant message placeholder
    const assistantMsg = addMessage('assistant', '');
    pendingTools.clear();

    // Send to API with SSE
    const response = await fetch('/api/conversations/' + conversationId + '/messages', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ content })
    });

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split('\n');
      buffer = lines.pop() || '';

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          try {
            const data = JSON.parse(line.slice(6));
            if (data.type === 'text') {
              assistantMsg.querySelector('.message-content').textContent += data.content;
            } else if (data.type === 'tool_use') {
              // Add pending tool execution UI
              addPendingToolExecution(assistantMsg, data.id, data.name, data.input);
            } else if (data.type === 'tool_result') {
              // Update tool execution with result
              updateToolExecutionResult(assistantMsg, data.id, data.name, data.result, data.durationMs);
            } else if (data.type === 'error' || data.error) {
              assistantMsg.classList.add('message-error');
              assistantMsg.querySelector('.message-content').textContent =
                'Error: ' + (data.error || data.message || 'Unknown error');
            }
          } catch (e) {}
        } else if (line.startsWith('event: error')) {
          // Next data line will be the error
        }
      }
    }

    messagesContainer.scrollTop = messagesContainer.scrollHeight;
  });

  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      form.requestSubmit();
    }
  });

  function addMessage(role, content) {
    // Remove empty state if present
    const emptyState = messagesContainer.querySelector('.empty-state');
    if (emptyState) emptyState.remove();

    const div = document.createElement('div');
    div.className = 'message message-' + role;
    div.innerHTML =
      '<div class="message-header"><span class="message-role">' + role + '</span></div>' +
      '<div class="message-content">' + escapeHtml(content) + '</div>';
    messagesContainer.appendChild(div);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
    return div;
  }

  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  function addPendingToolExecution(msgEl, toolId, toolName, input) {
    let container = msgEl.querySelector('.tool-executions');
    if (!container) {
      container = document.createElement('div');
      container.className = 'tool-executions';
      msgEl.appendChild(container);
    }

    const summary = getToolSummary(input);
    const toolEl = document.createElement('div');
    toolEl.className = 'tool-execution';
    toolEl.dataset.toolId = toolId;
    toolEl.innerHTML = `
      <div class="tool-pill" onclick="toggleToolExecution(this)">
        <span class="tool-pill-icon">▶</span>
        <span class="tool-pill-name">${escapeHtml(toolName)}${summary ? '("' + escapeHtml(summary) + '")' : ''}</span>
        <span class="tool-pill-duration">...</span>
        <span class="tool-pill-status pending">⏳</span>
      </div>
      <div class="tool-details">
        <pre class="tool-json">${escapeHtml(JSON.stringify(input))} → waiting...</pre>
      </div>
    `;
    container.appendChild(toolEl);
    pendingTools.set(toolId, { name: toolName, input });
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
  }

  function updateToolExecutionResult(msgEl, toolId, toolName, result, durationMs) {
    const toolEl = msgEl.querySelector(`.tool-execution[data-tool-id="${toolId}"]`);
    if (!toolEl) {
      // Tool wasn't tracked, create it with result
      addPendingToolExecution(msgEl, toolId, toolName, {});
      setTimeout(() => updateToolExecutionResult(msgEl, toolId, toolName, result, durationMs), 10);
      return;
    }

    // Update duration
    const durationEl = toolEl.querySelector('.tool-pill-duration');
    if (durationEl) {
      durationEl.textContent = durationMs + 'ms';
    }

    // Update status
    const statusEl = toolEl.querySelector('.tool-pill-status');
    if (statusEl) {
      statusEl.className = 'tool-pill-status ' + (result.success ? 'success' : 'error');
      statusEl.textContent = result.success ? '✓' : '✗';
    }

    // Update output in details
    const pending = pendingTools.get(toolId);
    const inputJson = pending ? JSON.stringify(pending.input) : '{}';
    const outputJson = result.error ? result.error : JSON.stringify(result.output);
    const jsonEl = toolEl.querySelector('.tool-json');
    if (jsonEl) {
      jsonEl.textContent = inputJson + ' → ' + outputJson;
    }

    pendingTools.delete(toolId);
  }

  // Scroll to bottom on load
  messagesContainer.scrollTop = messagesContainer.scrollHeight;
</script>

<%- include('partials/footer') %>
